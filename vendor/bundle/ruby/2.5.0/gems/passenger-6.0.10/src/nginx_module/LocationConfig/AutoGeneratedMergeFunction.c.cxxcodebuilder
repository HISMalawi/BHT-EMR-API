#  Phusion Passenger - https://www.phusionpassenger.com/
#  Copyright (c) 2010-2017 Phusion Holding B.V.
#
#  "Passenger", "Phusion Passenger" and "Union Station" are registered
#  trademarks of Phusion Holding B.V.
#
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#
#  The above copyright notice and this permission notice shall be included in
#  all copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
#  THE SOFTWARE.

# This file uses the cxxcodebuilder API. Learn more at:
# https://github.com/phusion/cxxcodebuilder

require 'phusion_passenger/nginx/config_options'

def main
  set_indent_string '    '
  comment copyright_header_for(__FILE__), 1

  separator

  comment %q{
    LocationConfig/AutoGeneratedMergeFunction.c is automatically generated from
    LocationConfig/AutoGeneratedMergeFunction.c.cxxcodebuilder,
    using definitions from src/ruby_supportlib/phusion_passenger/nginx/config_options.rb.
    Edits to LocationConfig/AutoGeneratedMergeFunction.c will be lost.

    To update LocationConfig/AutoGeneratedMergeFunction.c:
      rake nginx

    To force regeneration of LocationConfig/AutoGeneratedMergeFunction.c:
      rm -f src/nginx_module/LocationConfig/AutoGeneratedMergeFunction.c
      rake src/nginx_module/LocationConfig/AutoGeneratedMergeFunction.c
  }

  separator

  comment %q{
    0: NGX_CONF_ERROR, 1: OK
  }
  function('static int passenger_merge_autogenerated_loc_conf(passenger_autogenerated_loc_conf_t *conf, passenger_autogenerated_loc_conf_t *prev, ngx_conf_t *cf)') do
    filter_eligible_options(NGINX_CONFIGURATION_OPTIONS).each do |option|
      if option[:type] == :string
        add_code %Q{
          ngx_conf_merge_str_value(conf->#{struct_field_for(option)},
            prev->#{struct_field_for(option)},
            #{default_value_for(option) || "NULL"});
        }
      elsif option[:type] == :integer || option[:type] == :flag
        add_code %Q{
          ngx_conf_merge_value(conf->#{struct_field_for(option)},
            prev->#{struct_field_for(option)},
            #{default_value_for(option) || "NGX_CONF_UNSET"});
        }
      elsif option[:type] == :uinteger
        add_code %Q{
          ngx_conf_merge_uint_value(conf->#{struct_field_for(option)},
            prev->#{struct_field_for(option)},
            #{default_value_for(option) || "NGX_CONF_UNSET_UINT"});
        }
      elsif option[:type] == :string_array
        add_code %Q{
          if (merge_string_array(cf, &prev->#{struct_field_for(option)}, &conf->#{struct_field_for(option)}) != NGX_OK) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
              "cannot merge \\"#{option[:name]}\\" configurations");
            return 0;
          }
        }
      elsif option[:type] == :string_keyval
        add_code %Q{
          if (merge_string_keyval_table(cf, &prev->#{struct_field_for(option)}, &conf->#{struct_field_for(option)}) != NGX_OK) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
              "cannot merge \\"#{option[:name]}\\" configurations");
            return 0;
          }
        }
      else
        raise "Unknown option type #{option[:type].inspect} for option #{option[:name]}"
      end
    end

    separator
    add_code %q{
      return 1;
    }
  end
end

def filter_eligible_options(options)
  options.reject do |option|
    option[:alias_for] ||
      option.fetch(:field, true).nil? ||
      option[:field].to_s =~ /\./ ||
      option[:struct] == 'NGX_HTTP_MAIN_CONF_OFFSET' ||
      !option.fetch(:auto_generate_nginx_merge_code, true)
  end
end

def struct_field_for(option)
  if option.has_key?(:field)
    option[:field]
  else
    option[:name].sub(/^passenger_/, '')
  end
end

def default_value_for(option)
  case option[:type]
  when :string
    if option[:default]
      option[:default].inspect
    else
      "NULL"
    end
  when :integer
    if option[:default]
      option[:default]
    else
       "NGX_CONF_UNSET"
    end
  when :uinteger
    if option[:default]
      option[:default]
    else
      "NGX_CONF_UNSET_UINT"
    end
  when :flag
    if option.key?(:default)
      option[:default] ? '1' : '0'
    else
        "NGX_CONF_UNSET"
    end
  else
    raise "Unknown type #{option[:type].inspect} for option #{option[:name]}"
  end
end

main
