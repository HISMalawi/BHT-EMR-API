#  Phusion Passenger - https://www.phusionpassenger.com/
#  Copyright (c) 2017 Phusion Holding B.V.
#
#  "Passenger", "Phusion Passenger" and "Union Station" are registered
#  trademarks of Phusion Holding B.V.
#
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#
#  The above copyright notice and this permission notice shall be included in
#  all copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
#  THE SOFTWARE.

require 'build/support/vendor/cxx_hinted_parser/lib/cxx_hinted_parser'

def main
  result_class_fields = parse_result_class_fields
  comment copyright_header_for(__FILE__), 1
  separator

  comment %q{
    SpawningKit/Result/AutoGeneratedCode.h is automatically generated from
    SpawningKit/Result/AutoGeneratedCode.h.cxxcodebuilder by the build system.
    It uses the comment hints from SpawningKit/Result.h.

    To force regenerating this file:
      rm -f src/agent/Core/SpawningKit/Result/AutoGeneratedCode.h
      rake src/agent/Core/SpawningKit/Result/AutoGeneratedCode.h
  }

  separator


  function 'inline void Passenger::SpawningKit::Result::validate_autoGeneratedCode(' \
    'vector<StaticString> &internalFieldErrors, ' \
    'vector<StaticString> &appSuppliedFieldErrors) const' \
  do
    add_code %q{
      const Result &result = *this;
    }

    separator
    excluded_field_names = []

    result_class_fields.each do |field|
      if field.metadata[:supplied_by_app]
        error_collection = 'appSuppliedFieldErrors'
      else
        error_collection = 'internalFieldErrors'
      end
      if field.metadata[:require_non_empty]
        add_code %Q{
          if (OXT_UNLIKELY(#{field.name}.empty())) {
            #{error_collection}.push_back(P_STATIC_STRING("#{filename_for(field)} may not be empty"));
          }
        }
      elsif field.metadata[:require]
        add_code %Q{
          if (OXT_UNLIKELY(!(#{field.metadata[:require]}))) {
            #{error_collection}.push_back(P_STATIC_STRING("#{filename_for(field)} is not valid"));
          }
        }
      else
        excluded_field_names << field.name
      end
    end

    separator
    comment "Excluded:\n\n#{excluded_field_names.join("\n")}"
  end
end

def filename_for(field)
  key = field.metadata[:supplied_by_app]
  if key.is_a?(String)
    key
  else
    field.name.gsub(/([A-Z])/, '_\1').downcase
  end
end

def read_expression_for(field)
  case field.type
  when 'string'
    %Q{strip(readAll(dir + "/#{filename_for(field)}"))}
  when 'vector<Socket>'
    %Q{parseSocketJsonFile(dir + "/#{filename_for(field)}")}
  else
    raise "Unsupported field type '#{field.type}' for field #{field.name}"
  end
end

def parse_result_class_fields
  result_h = File.dirname(__FILE__) + '/../Result.h'
  parser = CxxHintedParser::Parser.load_file(result_h).parse
  parser.structs['Result']
end

main
